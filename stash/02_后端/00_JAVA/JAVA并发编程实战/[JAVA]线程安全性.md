---
title: [JAVA]线程安全性
---
### 简介

> 要编写线程安全的代码,其核心在于要对状态访问操作进行管理
>
> 从非正式的意义上来说,**对象的状态**是指在状态变量(例如实例或静态域)中的数据
>
> 当多个线程访问某个状态变量并且其中有一个线程执行写入操作时,必须采用**同步机制**来协同这些线程对变量的访问.java中的主要同步机制时关键字Synchronizad

有三种方式可以修复同步机制未能正确执行的问题

1. 不在线程之间共享该状态变量
2. 将状态变量修改为不可变的变量
3. 在访问状态变量时使用同步

### 线程安全的程序是否完全由线程安全的类构成

> 否,完全由线程安全类构成的程序并不一定就是线程安全的,而在线程安全类中也可以包含非线程安全的类

## 1. 什么是线程安全

在线程安全的定义中,最核心的概念就是**正确性**

正确性的含义是:某个类的行为与其规范完全一致.近似定义为"所见即所知".

从而定义线程安全性

> 当多个线程访问某个类时,(不管运行时环境采用何种调度方式或者这些线程将如何交替执行,并且在主调代码中不需要任何额外的同步或协同),这个类始终都能表现出正确的行为,那么就称这个类是线程安全的.

当一个对象是无状态的时候(也就是说在多线程中,不会有共享的域),这个对象一定是线程安全的

只有当一个对象增加一个状态时,才会出现线程安全问题

### 2. 原子性

当我们给无状态对象中增加一个状态`int a= 0`时,线程A和线程B同时获取了这个对象的状态

并且同时执行了a++

那么很有可能a++的操作之有一次有效的命中,那么在多次调用中返回相同的值将导致严重的数据完整性问题.

在多线程中,由于不恰当的执行时序而出现不确定的结果是一种非常重要的情况,被称为:

**竞态条件(RaceCondition)**

### 3. 加锁机制

3.1 内置锁

java提供了一中内置的锁机制来支持原子性: `同步代码块`

包含两个部分:

- 一个作为锁的对象引用

> 以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块

- 一个作为这个锁保护的代码块

> 该同步代码块的锁就是方法调用所在的对象

静态的synchronized方法以Class对象作为锁

3.2 重入

当一个线程请求一个由其他线程持有的锁时,发出请求的线程就会阻塞

然而,由于内置锁是**可重入**的,当一个线程试图获取一个已经头它自己持有的锁,这个请求就会成功

举例: 子类重写了父类中的synchronized doSomething()方法,在方法中调用了super.doSomething()

如果内置锁是不可重用的,那么在调用super.doSomething的时候将无法获得父类上的锁,代码将产生死锁

````java
public class Widget{
    public synchronized void doSomething(){
        ...
    }
}
public class LoggingWidget extends Widget{
    public synchronized void doSomething(){
        System.out.println("...");
        super.doSomething();
    }
}
````

### 4. 用锁来保护状态

> 对于可能被多个线程同时访问的可变状态变量,在访问它时都需要持有同一个锁,在这种情况下,我们称状态变量是由这个锁保护的

当某个变量由锁来保护时,意味着每次访问这个变量时都需要首先获得锁

当类的不变性条件涉及多个状态变量时,那么还有另外一个要求:

> 在不变性条件中的每一个变量都必须由同一个锁来保护

### 5. 活跃性与性能

如果多线程中各个线程的请求需要排队等待处理,那么,这种应用程序被称为:**不良(Poor Concurrency)并发应用程序**

通过缩小同步代码块的作用范围,能做到确保对象的并发性(简单讲是指在并发情况下缩短需要的时间),同时又能维护线程安全性

我觉得这一章比较难描述,所以还是拍了笔记,大概是这样:

![](https://raw.githubusercontent.com/nblilili/pic/master/pic/20181207202721.png)

​        上图这样子就是不良并发应用程序

![](https://raw.githubusercontent.com/nblilili/pic/master/pic/20181207202753.png)

​          改良后就是这样

要判断同步代码块的合理大小,需要在各种设计需求之间进行权衡,包括安全性(这个必须有),简单性(对整个方法进行同步)和性能(即代码块地行数越少越好)

> 在简单性和性能之间存在着相互制约因素.当实现某个同步策略时,一定不要盲目地为了性能而牺牲简单性(因为这可能会破坏安全性)

另外,当执行时间较长的计算或者可能无法快速完成的操所时,一定不要持有锁.

-------

收
